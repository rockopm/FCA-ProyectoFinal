<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Made with Remarkable!
  </title>
  <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
  <style type="text/css">
   body{font:16px Helvetica,Arial,sans-serif;line-height:1.4;color:#333;word-wrap:break-word;background-color:#fff;padding:10px 15px}strong{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{font-weight:700;position:relative;margin-top:15px;margin-bottom:15px;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;overflow:hidden;background:0 0;border:0;border-bottom:1px solid #ddd}a{color:#4183C4}a.absent{color:#c00}ol,ul{padding-left:15px;margin-left:5px}ol{list-style-type:lower-roman}table{padding:0}table tr{border-top:1px solid #ccc;background-color:#fff;margin:0;padding:0}table tr:nth-child(2n){background-color:#aaa}table tr th{font-weight:700;border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td{border:1px solid #ccc;text-align:left;margin:0;padding:6px 13px}table tr td :first-child,table tr th :first-child{margin-top:0}table tr td:last-child,table tr th :last-child{margin-bottom:0}img{max-width:100%}code{padding:0 5px;background-color:#d3d3d3}blockquote{padding: 0 15px;border-left:4px solid #ccc}
  </style>
 </head>
 <body id="MathPreviewF">
  <p>
   <em>
    Maestría en Ciencias Físicas: Física Computacional Avanzada
   </em>
  </p>
  <hr/>
  <h1 id="codigo-para-encontrar-rigurosamente-el-minimo-de-una-funcion-en-un-intervalo">
   Código para encontrar rigurosamente el mínimo de una función en un intervalo
  </h1>
  <p>
   <strong>
    Christian Marchen
    <mathjax>
     $^{(1)}$
    </mathjax>
    , Rodrigo Pineda Mondragón
    <mathjax>
     $^{(2)}$
    </mathjax>
   </strong>
  </p>
  <p>
   (1) Maestría en Ciencias Matemáticas, IIMAS, UNAM. GitHub: hierro40
   <br/>
   (2) Maestría en Ciencias Matemáticas, IIMAS, UNAM. GitHub: rockopm
  </p>
  <hr/>
  <p>
   <em>
    <br/>
    <strong>
     Abstract:
    </strong>
    El problema de optimización de funciones es ubicuo en el mundo de las matemáticas aplicadas. La física, las finanzas, la biología, las ecuaciones diferenciales y demás ciencias que utilizan las matemáticas como herramienta de estudio convergen en algún punto en algún problema de optimización. Además, la complejidad de los nuevos modelos matemáticos desarrollados en estas ciencias nos obligan a hacer uso de herramientas computacionales cuando estos carecen de soluciones en forma cerradas. Existen métodos numéricos desarrollados para resolver el problema de encontrar el mínimo de una función dada una aproximación inicial, pero la mayoría de estos arrojan soluciones que dependen de esta primera aproximación dada por el usuario. Sin embargo, los métodos para encontrar raíces de funciones han sido extendidos para utilizar intervalos como aproximación inicial, en vez de puntos, por lo que el hecho de que
    <mathjax>
     $f'(x) = 0$
    </mathjax>
    implique un punto crítico de
    <mathjax>
     $f$
    </mathjax>
    nos ayuda a mejorar estos métodos para encontrar raíces de la derivada de esta función y así concluir si es un mínimo o no. En este trabajo desarrollamos un código rigusoro basado en el
    <strong>
     método de Krawczyk
    </strong>
    para encontrar los mínimos de una función en un intervalo dado por el usuario. Utilizamos un catálogo de
    <strong>
     funciones suaves
    </strong>
    para mostrar la efectividad del método.
   </em>
  </p>
  <h2 id="introduccion">
   Introducción
  </h2>
  <p>
   Los problemas de optimización en escencia consisten en obtener el valor mínimo
   <mathjax>
    $y^*$
   </mathjax>
   de una función
   <mathjax>
    $f : D \rightarrow \mathbb{R}$
   </mathjax>
   dada en una región
   <mathjax>
    $D$
   </mathjax>
   . Es decir:
  </p>
  <p>
   <mathjax>
    $$y^* = y^*(f;D) = \inf \{f(x): x \in D \}$$
   </mathjax>
  </p>
  <p>
   así como el conjunto de puntos del dominio
   <mathjax>
    $D$
   </mathjax>
   donde se alcanza dicho mínimo:
  </p>
  <p>
   <mathjax>
    $$E^* = E^*(f:D) = \{ x^* \in D: f(x^*) = y^* \}$$
   </mathjax>
  </p>
  <p>
   Para el caso en que el problema de optimización requiera encontrar un valor máximo en vez de un mínimo entonces basta con minimizar la función
   <mathjax>
    $-f$
   </mathjax>
   . Se asume que
   <mathjax>
    $f$
   </mathjax>
   es continua en su dominio
   <mathjax>
    $D$
   </mathjax>
   , el cuál es un compacto. Entonces, dado que toda función continua en un intervalo cerrado y acotado alcanza un mínimo, tendremos que el conjunto
   <mathjax>
    $E^*$
   </mathjax>
   es no vacío.
  </p>
  <p>
   Utilizaremos técnicas de análisis de intervalos para ubicar a
   <mathjax>
    $y^*$
   </mathjax>
   y
   <mathjax>
    $E^*$
   </mathjax>
   en un intervalo suficientemente pequeño para que nos brinde información concluyente. Comenzando con el valor extremo
   <mathjax>
    $y^*$
   </mathjax>
   podemos expresarlo como:
  </p>
  <p>
   <mathjax>
    $$y^* = \inf \{ y : y \in R(f;D) \},$$
   </mathjax>
  </p>
  <p>
   donde
   <mathjax>
    $R(f;D) = \{ f(x) : x \in D \}$
   </mathjax>
   . Por lo tanto, si podemos encerrar
   <mathjax>
    $R(f;D)$
   </mathjax>
   en un intervalo suficientemente pequeño, entonces inmediatamente tendremos un intervalo suficientemente pequeño que encierre a
   <mathjax>
    $y^*$
   </mathjax>
   .
  </p>
  <p>
   Las técnicas a utilizar conocidas son muy similares a los métodos para encontrar ceros, como el método de Newton para intervalos visto en clase. Excluyendo los subconjuntos de
   <mathjax>
    $D$
   </mathjax>
   , se tratará de resolver el problema:
  </p>
  <p>
   <mathjax>
    $$f(x) \leq \bar{y} $$
   </mathjax>
  </p>
  <p>
   pero con una
   <mathjax>
    $\bar{y}$
   </mathjax>
   variable, que es la cota superior actual de
   <mathjax>
    $y^*$
   </mathjax>
   . Durante el proceso de resolver esta última expresión encontraremos un valor cada vez más pequeño para
   <mathjax>
    $\bar{y}$
   </mathjax>
   , la meta será hacer
   <mathjax>
    $\bar{y}$
   </mathjax>
   lo más cercano posible a
   <mathjax>
    $y^*$
   </mathjax>
   , ya que estaríamos llegando al conjunto deseado:
  </p>
  <p>
   <mathjax>
    $$E^* = \{ x^* \in D : f(x^*)\leq y^*\} = \{ x^* \in D : f(x^*)=y^* \}$$
   </mathjax>
  </p>
  <p>
   Entonces, deseamos encontrar un intervalo
   <mathjax>
    $X$
   </mathjax>
   que contenga a
   <mathjax>
    $y^*$
   </mathjax>
   . Se pueden utilizar distintos criterios para descartar los subintervalos en la búsqueda. En nuestro caso utilizamos un criterio de bisección para dividir el intervalo de búsqueda y usamos el resulado principal del
   <strong>
    método de Krawczyk
   </strong>
   para descartar intervalos que no contengan el mínimo
   <mathjax>
    $^{[1]}$
   </mathjax>
   .
  </p>
  <h2 id="metodo-de-krawczyk">
   Método de Krawczyk
  </h2>
  <p>
   El
   <strong>
    método de Krawczyk
   </strong>
   es una alternativa al método de Newton para encontrar ceros de funciones, pues Krawczyk evita los problemas de dividir entre el intervalo
   <mathjax>
    $F'(X)$
   </mathjax>
   cuando estamos haciendo las iteraciones del método de Newton. El método se deriva como sigue.
  </p>
  <p>
   Se supone que
   <mathjax>
    $f \in C^1 (X \in \mathbb{R})$
   </mathjax>
   tiene un cero
   <mathjax>
    $x^* \in X$
   </mathjax>
   . Expandimos en Taylor alrededor de
   <mathjax>
    $x^*$
   </mathjax>
   para obtener:
  </p>
  <p>
   <mathjax>
    $$f(x)=f(x^*)+f'(\xi)(x-x^*)$$
   </mathjax>
  </p>
  <p>
   para algún
   <mathjax>
    $\xi$
   </mathjax>
   entre
   <mathjax>
    $x$
   </mathjax>
   y
   <mathjax>
    $x^*$
   </mathjax>
   . Para lo anterior tenemos
   <mathjax>
    $f(x^*) = 0$
   </mathjax>
   , por ser una raíz. Multiplicamos la expansión por alguna constante
   <mathjax>
    $C$
   </mathjax>
   :
  </p>
  <p>
   <mathjax>
    $$C f(x) = C f'(\xi)(x-x^*)$$
   </mathjax>
  </p>
  <p>
   y añadiendo
   <mathjax>
    $x^*-x$
   </mathjax>
   en ambos lados de la ecuación tenemos:
  </p>
  <p>
   <mathjax>
    $$x^*-x+Cf(x)=(x^*-x)+Cf'(\xi)(x-x^*).$$
   </mathjax>
  </p>
  <p>
   Reacomodando términos se obtiene:
  </p>
  <p>
   <mathjax>
    $$x^*=x-Cf(x)-(1-Cf'(\xi))(x-x^*).$$
   </mathjax>
  </p>
  <p>
   Aunque no conocemos la raíz
   <mathjax>
    $x^*$
   </mathjax>
   ni el punto
   <mathjax>
    $\xi$
   </mathjax>
   , sabemos que ambos puntos pertenecen al dominio
   <mathjax>
    $X$
   </mathjax>
   . Por lo que podremos acotar ambos y obtener lo siguiente:
  </p>
  <p>
   <mathjax>
    $$x^* \in x-Cf(x)-(1-CF'(X))(x-X) \equiv K(X,x,C)$$
   </mathjax>
  </p>
  <p>
   <em>
    Resultado
   </em>
   : Hemos probado que cualquier cero
   <mathjax>
    $x^* \in x$
   </mathjax>
   de
   <mathjax>
    $f$
   </mathjax>
   esta acotado por los extremos del
   <strong>
    operador de Krawczyk
   </strong>
   <mathjax>
    $K(X,x,C)$
   </mathjax>
   , para cualquier
   <mathjax>
    $x \in X$
   </mathjax>
   y una
   <mathjax>
    $C$
   </mathjax>
   finita. Elegimos
   <mathjax>
    $x = m = \textrm{mid}(X)$
   </mathjax>
   y
   <mathjax>
    $C=1/f'(m)$
   </mathjax>
   <mathjax>
    $^{[1,2]}$
   </mathjax>
   .
  </p>
  <p>
   Finalmente el operador de Krawcyk resulta:
  </p>
  <p>
   \begin{equation}
   <br/>
   K(X) = K(X,m,1/f’(m)) = m-\frac{f(m)}{f’(m)}-\frac{1-F’(X)}{f’(m)}[-r,r]
   <br/>
   \end{equation}
  </p>
  <p>
   Donde
   <mathjax>
    $r=\textrm{rad}(X)$
   </mathjax>
   . Dado un intervalo inicial
   <mathjax>
    $X_0$
   </mathjax>
   donde buscamos una raíz
   <mathjax>
    $x^*$
   </mathjax>
   , definimos la secuencia de intervalos:
  </p>
  <p>
   <mathjax>
    $$X_{k+1} = K(X_k) \cap X_k, \qquad k=0,1,2,...$$
   </mathjax>
  </p>
  <p>
   como las
   <strong>
    iteraciones de Krawczyk
   </strong>
   de
   <mathjax>
    $X_0$
   </mathjax>
   . Sea
   <mathjax>
    $m_k = \textrm{mid}(X_k)$
   </mathjax>
   . Mientras
   <mathjax>
    $f'(m_k) \neq 0$
   </mathjax>
   para toda
   <mathjax>
    $k \in \mathbb{N}$
   </mathjax>
   , se dice que la secuencia esta
   <em>
    bien definida
   </em>
   . De lo anterior, obtenemos el siguiente resultado.
  </p>
  <p>
   <strong>
    Teorema.
   </strong>
   Suponiendo que
   <mathjax>
    $K(X)$
   </mathjax>
   está bien definido, entonces los siguientes se cumple:
  </p>
  <p>
   (1) si
   <mathjax>
    $X$
   </mathjax>
   contiene una raíz
   <mathjax>
    $x^*$
   </mathjax>
   de
   <mathjax>
    $f$
   </mathjax>
   , entonces el cero también está contenido en
   <mathjax>
    $K(X) \cap X$
   </mathjax>
   ;
  </p>
  <p>
   (2) si
   <mathjax>
    $K(X) \cap X = \emptyset$
   </mathjax>
   , entonces
   <mathjax>
    $X$
   </mathjax>
   no contiene ceros; y
  </p>
  <p>
   (3) si
   <mathjax>
    $K(X) \subseteq \textrm{int}(X)$
   </mathjax>
   , entonces
   <mathjax>
    $X$
   </mathjax>
   contiene exactamente un cero, donde
   <mathjax>
    $\textrm{int}(X) = \{ x : \inf(X) &lt; x &lt; \sup(X) \}$
   </mathjax>
   .
  </p>
  <p>
   <strong>
    Código.
   </strong>
   Llamamos
   <em>
    Krawczyk.jl
   </em>
   al módulo donde se implementa este método y se puede encontrar en
   <a href="https://github.com/rockopm/FCA-ProyectoFinal/blob/master/Krawczyk.jl">
    https://github.com/rockopm/FCA-ProyectoFinal/blob/master/Krawczyk.jl
   </a>
   .
  </p>
  <p>
   En el módulo de
   <code>
    Krawczyk.jl
   </code>
   se construye la función
   <code>
    optimiza(X::Intervalo, f::Function, err)
   </code>
   que tiene como argumentos
   <code>
    X::Intervalo
   </code>
   que es el intervalo inicial con que se empieza la iteración de Krawczyk,
   <code>
    f::Function
   </code>
   que corresponde a la función que se desea optimizar, y
   <code>
    err
   </code>
   que es un valor de precisión con que deseamos el resultado aproximado. Esta función devuelve una
   <em>
    n-tupla
   </em>
   de la forma
  </p>
  <p>
   <mathjax>
    $$(y^*, X^*),$$
   </mathjax>
  </p>
  <p>
   donde
   <mathjax>
    $y^*$
   </mathjax>
   es el valor mínimo de la función
   <mathjax>
    $f$
   </mathjax>
   y
   <mathjax>
    $X^*$
   </mathjax>
   es el intervalo en el dominio donde se encuentra el punto
   <mathjax>
    $x^*$
   </mathjax>
   tal que
   <mathjax>
    $y^* = f(x^*)$
   </mathjax>
   .
  </p>
  <h2 id="modulos">
   Módulos
  </h2>
  <h3 id="derivadasjl">
   Derivadas.jl
  </h3>
  <p>
   Utilizamos el hecho de que las si
   <mathjax>
    $x^*$
   </mathjax>
   es mínimo de
   <mathjax>
    $f$
   </mathjax>
   entonces
   <mathjax>
    $f'(x^*) = 0$
   </mathjax>
   . De esta forma, utilizamos el método de Krawczyk en las derivada de la función
   <mathjax>
    $f$
   </mathjax>
   para encontrar los mínimos en un intervalo
   <mathjax>
    $X$
   </mathjax>
   de
   <mathjax>
    $f$
   </mathjax>
   .
  </p>
  <p>
   Para usar la derivada de una función
   <mathjax>
    $f$
   </mathjax>
   dada por el usuarios, sin que dicha derivada se especifíque explícitamente, usamos una extensión del módulos
   <code>
    Derivadas.jl
   </code>
   desarrollado en clase.
  </p>
  <p>
   En aquella ocasión, en el notebook 6, desarrollamos un módulo que permitía evaluar funciones en un objeto denominado
   <code>
    Derivada(x, x')
   </code>
   en donde se obtenía como resultado un objeto del mismo tipo
   <code>
    Derivada(f, f')
   </code>
   donde
   <code>
    f
   </code>
   es la función
   <mathjax>
    $f$
   </mathjax>
   evaluada en el punto
   <mathjax>
    $x$
   </mathjax>
   y
   <code>
    f'
   </code>
   es su derivada evaluada en el mismo punto.
  </p>
  <p>
   Para este trabajo, extendemos el módulo para que este contenga también la segunda derivada de la función, obteniendo como resultados objetos del tipo
   <code>
    Derivada(f,f',f'')
   </code>
   .
  </p>
  <p>
   <strong>
    Código.
   </strong>
   Éste módulo lo llamamos
   <em>
    Derivadas.jl
   </em>
   y se puede obtener en
   <a href="https://github.com/rockopm/FCA-ProyectoFinal/blob/master/Derivadas.jl">
    https://github.com/rockopm/FCA-ProyectoFinal/blob/master/Derivadas.jl
   </a>
   .
  </p>
  <h3 id="intervalosjl">
   Intervalos.jl
  </h3>
  <p>
   Para utilizar intervalos como argumento de las funciones a utilizar, mejoramos a detalle el módulo
   <code>
    Intervalos.jl
   </code>
   hecho en clase. Utilizamos teoremas derivados de la artimética de intervalos para definir el intervalo vacío y las operaciones aritméticas de suma, resta, multiplicación y división
   <mathjax>
    $^{[3]}$
   </mathjax>
   .
  </p>
  <p>
   La implementación del módulo y los detalles de las matemáticas relacionadas se pueden encontrar en
   <a href="https://github.com/lbenet/MetodosNumericosAvanzados/blob/master/notebooks">
    https://github.com/lbenet/MetodosNumericosAvanzados/blob/master/notebooks
   </a>
   en el notenook 7.
  </p>
  <p>
   <strong>
    Código.
   </strong>
   Llamamos
   <em>
    Intervalos.jl
   </em>
   al módulo dedicado a la aritmética de intervalos, y este lo puedes encontrar en
   <a href="https://github.com/rockopm/FCA-ProyectoFinal/blob/master/Intervalos.jl">
    https://github.com/rockopm/FCA-ProyectoFinal/blob/master/Intervalos.jl
   </a>
   .
  </p>
 </body>
</html>